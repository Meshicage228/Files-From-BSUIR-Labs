#include <stdio.h>
#include <stdlib.h>
#include <iostream>
using namespace std;

#define N 9
struct Node {
    int dest;
    struct Node* next;
    int priority;
};
struct Graph {
   Node* head[N];
};
struct Edge {
    int src, dest, prior;
};

 Graph* createGraph(Edge edges[], int n) {
    Graph* graph = new Graph();

    for (int i = 0; i < N; i++) {
        graph->head[i] = NULL;
    }
    for (int i = 0; i < n; i++) {
        int src = edges[i].src;
        int dest = edges[i].dest;
        int node = edges[i].prior;
        Node* newNode = new Node();
        newNode->dest = dest;
        newNode->priority = node;
        newNode->next = graph->head[src];
        graph->head[src] = newNode;
    }
    return graph;
}
void printGraph(Graph* graph) {
    for (int i = 0; i < N; i++) {
        Node* ptr = graph->head[i];
        while (ptr != NULL) {
            cout << i << " -> " << ptr->dest << "(" << ptr->priority << ")" << "  ";
            ptr = ptr->next;
        }
        cout << endl;
    }
    cout << endl;
}
Graph* deleteNode(Edge tp[], int n, int kat) {
    Graph* newendge = new Graph();
    for (int i = 0; i < N; i++) {
        newendge->head[i] = NULL;
    }
    for (int i = 0; i < n ; i++) {
        if (tp[i].prior == kat) continue;
        else {
            int src = tp[i].src;
            int dest = tp[i].dest;
            int node = tp[i].prior;
            Node* newNode = new Node();
            newNode->dest = dest;
            newNode->priority = node;
            newNode->next = newendge->head[src];
            newendge->head[src] = newNode;
        }
    }
    return newendge;
}
Graph* deleteVerible(Edge tp[], int n, int x) {
    Edge withoutx[26];
    Graph* newendge = new Graph();
    for (int i = 0; i < N; i++) {
        newendge->head[i] = NULL;
    }
    for (int i = 0; i < n; i++) {
        if (tp[i].dest == x || tp[i].src == x) {
            continue;
        }
        else {
            int src  = tp[i].src;
            int dest = tp[i].dest;
            int node = tp[i].prior;
            Node* newNode = new Node();
            newNode->dest = dest;
            newNode->priority = node;
            newNode->next = newendge->head[src];
            newendge->head[src] = newNode;
        }
    }
    return newendge;
}
void ShowMatrix(Edge t[], int n) {
    bool** arr = new bool* [N];
    for (int i = 0; i < N; i++)
    {
        arr[i] = new bool[N];
    }
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            arr[i][j] = false;
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl;
    for (int i = 0; i < n; i++)
    {
        int a = t[i].src;
        int b = t[i].dest;
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < N; j++)
            {
                arr[a][b] = true;
            }
        }
    }
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl;
}
int main() {
    Edge edges[] = {
        {1, 2, 3}, {1, 7, 2}, {1, 8, 4},
        {2, 1, 3}, {2, 7, 2}, {2, 3, 1}, {2, 5 ,4},
        {7, 1, 2}, {7, 2, 2}, {7, 8, 2}, {7, 5, 7},
        {3, 2, 1}, {3, 5, 4}, {3, 4, 3},
        {4, 3, 3}, {4, 5, 2}, {4, 6, 1}, 
        {5, 3, 4}, {5, 4, 2}, {5, 6, 7}, {5, 7, 7}, {5, 8, 6}, {5, 2 ,4},
        {6, 8, 3}, {6, 4, 1}, {6, 5, 7},
        {8, 1, 4}, {8, 7, 2}, {8, 6, 3}, {8, 5, 6},
    };
    int n = sizeof(edges) / sizeof(edges[0]);
    cout << "Full Grath : " << endl;
    Graph* graph = createGraph(edges, n);
    printGraph(graph);
    cout << "Without 2 node : " << endl;
    Graph* newgrath2 = deleteNode(edges, n, 2);
    printGraph(newgrath2);
    cout << "Without vertex 7  : " << endl;
    Graph* newgrath3 = deleteVerible(edges, n, 7);
    printGraph(newgrath3);
    cout << "Matrix : " << endl;
    ShowMatrix(edges, n);
    return 0;
}